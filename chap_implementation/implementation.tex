\chapter{Implementation}

\section*{Introducci\'on al cap\'itulo}
En este cap\'itulo mostramos algunos ejemplos obtenidos 
con programas que desarrollamos para esta tesis.

En la Secci\'on~\ref{auxlabel214} mostramos ejemplos de mallado 
obtenidos con la implementaci\'on de nuestro proceso propuesto 
en la Subsecci\'on~\ref{meshes}. 
En este caso usamos el dominio de Fichera como ejemplo can\'onico 
de dominio singular en $\mathbb{R}^3$.

Esta primera versi\'on del programa de mallado se puede ver en el siguiente 
repositorio~\cite{alexis}.

El programa que implementa la resoluci\'on num\'erica con nuestro esquema
$FEM/VEM$ en las mallas h\'ibridas se encuentra en desarrollo y ser\'a
usado en experimentos num\'ericos en trabajos futuros.

En la Secci\'on~\ref{auxlabel215} mostramos resultados num\'ericos
cuando aplicamos nuestro m\'etodo a un dominio descompuesto en macro--elementos
de un solo tipo, el macro--elemento prism\'atico con una arista singular y sin v\'ertices
singulares.

\section*{Introduction to the chapter}
In this chapter we show some examples obtained with programs we 
developed for the present thesis.

In Section~\ref{auxlabel214} we show a meshing example made with the implementation
of the procedure we proposed in Subsection~\ref{meshes}. In this case we used
the Fichera domain as a canonical example of a singular domain in $\mathbb{R}^3$.

This first version of the meshing program can be found in the following repository~\cite{alexis}.

The program that implements the numerical solution with our $FEM/VEM$ scheme
over the hybrid meshes of Subsection~\ref{meshes} is being developed and will
be used in numerical experiments of future works.

In Section~\ref{auxlabel215} we show numerical results when we
apply our method to a domain made exclusively of one kind of macro--elements,
namely, the prismatic macro--element with a singular edge and no singular vertex.

\section{Examples Of The Meshing Procedure In Dimension $3$} % (fold)
\label{auxlabel214}
Figure~\ref{auxlabel206} shows the partition $\pazocal{T}_{\textit{h}_0}$ (cfr. Remark~\ref{auxlabel216}) of the Fichera Domain 
$\Omega:=(-1,1)^3\,\setminus\,(0,1)^3$ from four different azimuthal 
angles. 

\tauZero 

\newpage
Here is a sample of the output of the program in the following instance:
$\Omega = (-1,1)^3\setminus\,(0,1)^3$ with $35$ macro--elements, one singular
vertex at $\boldsymbol{0}$ and three concurrent singular edges. Grading parameter
$\mu = .65$ with $6$ levels of refinement ($7$ nodes per macro--element edge).

{\tiny
\begin{verbatim}
         vertices.txt                faces.txt       elements_by_vertices.txt   elements_by_faces.txt

 1. -1.00000  1.00000  1.00000     1. 3 1 4 2           1. 6 1 4 2 7 9 8           1. 2 1 2 3 4 5
 2. -1.00000  1.00000  0.50000     2. 3 7 9 8           2. 4 2 5 3 8               2. 0 6 7 8 9 0
 3. -1.00000  1.00000  0.00000     3. 4 4 1 9 7         3. 4 4 6 5 9               3. 0 10 11 12 13 0
 4. -1.00000  0.50000  1.00000     4. 4 1 2 7 8         4. 5 2 4 9 8 5             4. 1 14 7 15 12 5
 5. -1.00000  0.50000  0.50000     5. 4 2 4 8 9         5. 4 7 9 8 10              5. 0 2 16 17 18 0
 6. -1.00000  0.00000  1.00000     6. 3 2 5 3           6. 6 11 14 12 17 19 18     6. 2 19 20 21 22 23
 7. -0.50000  1.00000  1.00000     7. 3 2 5 8           7. 4 12 5 6 18             7. 0 24 25 26 27 0
 8. -0.50000  1.00000  0.50000     8. 3 2 3 8           8. 4 14 3 5 19             8. 0 28 29 30 31 0
 9. -0.50000  0.50000  1.00000     9. 3 5 3 8           9. 5 12 14 19 18 5         9. 1 32 25 33 30 23
10.  0.00000  1.00000  1.00000    10. 3 4 6 5          10. 4 17 19 18 20          10. 0 20 34 35 36 0
11. -1.00000  0.00000  0.00000    11. 3 4 6 9          11. 4 20 18 19 24          11. 0 36 37 38 39 0
12. -1.00000  0.00000  0.34425    12. 3 4 5 9          12. 4 18 6 5 9             12. 0 27 40 41 13 0
13. -1.00000  0.00000  1.00000    13. 3 6 5 9          13. 4 19 5 3 8             13. 0 31 42 43 9 0
14. -1.00000  0.34425  0.00000    14. 3 2 4 5          14. 4 24 9 8 10            14. 0 44 45 46 18 0
15. -1.00000  0.50000  0.50000    15. 3 9 8 5          15. 4 18 19 24 9           15. 0 39 47 48 49 0
16. -1.00000  1.00000  0.00000    16. 3 7 9 10         16. 4 19 24 9 8            16. 0 49 50 51 44 0
17. -0.34425  0.00000  0.00000    17. 3 7 8 10         17. 4 18 19 5 9            17. 0 33 47 41 52 0
18. -0.34425  0.00000  0.34425    18. 3 9 8 10         18. 4 19 5 9 8             18. 0 52 42 51 15 0
19. -0.34425  0.34425  0.00000    19. 3 11 14 12             ...                           ...        
20.  0.00000  0.00000  0.00000    20. 3 17 19 18  
21.  0.00000  0.00000  0.00000    21. 4 14 11 19 17                                                                             ...
22. -0.34425  0.00000  0.34425    22. 4 11 12 17 18      
23. -0.34425  0.34425  0.00000    23. 4 12 14 18 19           
24.  0.00000  0.34425  0.34425    24. 3 12 5 6                   
25. -0.34425  0.00000  0.34425    25. 3 12 5 18                   
26. -1.00000  0.00000  1.00000    26. 3 12 6 18                   
27. -1.00000  0.50000  0.50000    27. 3 5 6 18                   
28. -0.50000  0.50000  1.00000    28. 3 14 3 5                   
29. -0.34425  0.34425  0.00000    29. 3 14 3 19                   
30. -1.00000  0.50000  0.50000    30. 3 14 5 19                   
             ...                       ...

\end{verbatim}}

Then in Figure~\ref{auxlabel300} we show how the hybrid mesh 
looks like in a tetrahedral
macro--element as in Subsubsection~\ref{caso4}. 

\macroElement3

Figure~\ref{auxlabel301} shows the detail of the decomposition into macro--elements
of a cube defined as the intersection of $\Omega$ with an arbitrary octant. The 
cube consists of five tetrahedral macro--elements; a regular tetrahedron
in the center of the cube meshed as a macro--element from 
Subsubsection~\ref{auxlabel302} and four more macro--tetrahedra as in 
Subsubsection~\ref{caso4}.

\tauOneEnCube

Finally in Figure~\ref{auxlabel303} we can see the whole domain $\Omega$
meshed with our anisot\-ropic grading procedure.

\tauOneEn
Additionally, we found interesting to illustrate some experiments
that confirm the conformity of the meshes. These can be seen in 
Figure~\ref{auxlabel305}. In Subfigure~\ref{auxlabel405} the idea is
to show edge conformity from one macro--element to another, whereas 
in Subfigures~\ref{auxlabel406}--\ref{auxlabel404} we can see
face conformity between macro--elements.

\conform\newpage
\section{Numerical 
Experiments in Cylindrical Domains with Edge Singularities}
\label{auxlabel215}

In Figure~\ref{auxlabel204} we put a cylindrical singular domain to show
the kind of problems we started to work with to develop our method.
\edgedomain
In Figures~\ref{auxlabel212} and~\ref{auxlabel310} we can
compare the sectional views of a uniform mesh against
a graded anisotropic refinement (the anisotropy becomes evident
when we consider the third orthogonal direction).
\gradSection
Finally, Tables~\ref{table_errors_1} and~\ref{table_errors_2}
are presented to compare the approximation rate for the vectorial variable
with quasi--uniform mesh against the one with an anisotropic
cartesian product mesh. These experiments correspond to the instance of the 
problem which is also
solved in~\cite{MR1866274}, as pointed out before in this Thesis. 
As we wrote in the previous chapters, we focused on problems in general
polyhedral domains, whith edge and vertex singularities, and proposed
a more general meshing procedure, combining different types of elements, and
as we said in the introduction of the present chapter, the program calculating
the solution with our $FEM/VEM$ scheme
over the hybrid meshes of Subsection~\ref{meshes} will
be finished for future works. 

\tableErrorsUniformCylinder 
\tableErrorsAnisoCylinder 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO
%\begin{algorithm}
%	\begin{algorithmic}
%		\State vertices $\leftarrow$ load(verticesCoordinates)
%		\State elementVertices $\leftarrow$ load(elementsByVerticesIndices)
%		\State faces $\leftarrow$ load(facesCoordinates)
%		\State elementFaces $\leftarrow$ load(elementsByFacesIndices)
%
%		\ForAll{element}
%			\State v $\gets$ verticesOf(element,vertices)
%		\EndFor
%	\end{algorithmic}
%\end{algorithm}
%